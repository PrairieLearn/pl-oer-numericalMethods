<pl-question-panel>
<h1>Bisection Method for Root-Finding in 1D</h1>
<!-- <h2>Introduction</h2>
  <p>A zero $z$ of a function $f(x)$ is a value of $x$ such that $f(z) = 0$.
    This problem deals with a method to find zeros.</p>
  <p>A so-called <em>black-box</em> zero-finding method is only allowed to
    evaluate the function $f$ at some $x$s of its choosing-it does not
    usually have any special knowledge about the function-it treats
    the function as a <em>black box</em>.
    These function evaluations are typically viewed as <em>expensive</em>, so
    whatever method does fewest of them wins. Usually, both $x$ and $f$
    are vector-valued, but in this problem, we'll assume that they're
    just scalars. We'll get to the vector-valued case later in the
    class. As an example, consider a material scientist who, using a
    complicated computer program, can figure out what composition of
    alloy has what tensile strength. But what if the scientist wants the opposite?
    Assume the tensile strength is known, but the scientist wants to know a possible
    composition of an alloy.</p>
  <p>By the way, there's a reason we care so much about just <em>zeros</em>:
    If you can find a zero, you can solve <em>any</em> equation $f(x)=c$:
    You can just run your zero-finding method on
    a new function $g(x)=f(x)-c$, and a zero of $g$ will solve $f(x)=c$.</p> -->
<p>You are given a list of tuples <code>intervals</code>, where each tuple <code>(a,b)</code> denotes the interval $[a,b]$. For a continuous 1D function $f$ given as <code>function</code>, use the bisection method to find a root on each interval. Save each root to the list <code>roots</code> if it has been found successfully or save <code>None</code> to the list otherwise.</p>
<p>For an interval $[a,b]$, finding the root with the bisection method entails the following:</p>
<ol>
<li>For the bisection method to work, it must hold that $a \lt b$ and $\text{sign}(f(a)) \ne \text{sign}(f(b))$. If either of these conditions are not met, you should return <code>None</code>.</li>
<li>Let $m$ be the midpoint of the interval $[a,b]$.</li>
<li>If $|f(m)| \leq \epsilon$ then return $m$</li>
<li>
<p>Otherwise, distinguish cases:</p>
<ul>
<li>If $f(m)$ has the same sign as $f(a)$, then the root is in the interval $[ m, b ]$, so let $a = m$.</li>
<li>If $f(m)$ has the same sign as $f(b)$, then the root is in the interval $[ a, m ]$, so let $b = m$.</li>
</ul>
</li>
<li>Repeat from step 2. If the algorithm does not converge after <code>n_iter</code> iterations, return <code>None</code>.</li>
</ol>
<p> The setup code gives the following variables: </p>
<pl-external-grader-variables params-name="names_for_user"></pl-external-grader-variables>
<p> Your code snippet should define the following variables: </p>
<pl-external-grader-variables params-name="names_from_user"></pl-external-grader-variables>
<pl-file-editor ace_mode="ace/mode/python" file_name="user_code.py" source-file-name="tests/initial_code.py">
</pl-file-editor>
</pl-question-panel>
<pl-submission-panel>
<pl-external-grader-results></pl-external-grader-results>
<pl-file-preview></pl-file-preview>
</pl-submission-panel>
<pl-question-panel>
<hr/>
<p class="small text-muted">
    Problem is from the <a href="https://www.prairielearn.com/oer">PrairieLearn OER repository</a>, licensed under the <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0 license</a>.
    </p>
</pl-question-panel>
